/**\n * Deployment Strategy Demonstration\n * \n * This file demonstrates the comprehensive deployment strategy for CodeRunner v2.0\n * including lifecycle management, error handling, and cleanup mechanisms.\n */\n\nimport { OrchestrationService } from '../services/orchestration';\nimport { DatabaseService } from '../services/database';\nimport { DeploymentStatus } from '../types/index';\n\n/**\n * Demo deployment scenarios to showcase the strategy\n */\nclass DeploymentStrategyDemo {\n  private orchestrationService: OrchestrationService;\n  private databaseService: DatabaseService;\n\n  constructor() {\n    this.orchestrationService = OrchestrationService.getInstance();\n    this.databaseService = DatabaseService.getInstance();\n  }\n\n  /**\n   * Demonstrate complete deployment lifecycle\n   */\n  async demonstrateDeploymentLifecycle(): Promise<void> {\n    console.log('\\nüöÄ === Deployment Lifecycle Demo ===');\n    \n    try {\n      // 1. Deploy a simple Node.js application\n      const deployment1 = await this.deploySimpleNodeApp();\n      console.log('‚úÖ Simple Node.js app deployed:', deployment1);\n      \n      // 2. Deploy a complex React application \n      const deployment2 = await this.deployComplexReactApp();\n      console.log('‚úÖ Complex React app deployed:', deployment2);\n      \n      // 3. Monitor both deployments\n      await this.monitorDeployments([deployment1.deploymentId, deployment2.deploymentId]);\n      \n      // 4. Simulate error and recovery\n      await this.simulateErrorRecovery(deployment1.deploymentId);\n      \n      // 5. Demonstrate cleanup\n      await this.demonstrateCleanup();\n      \n    } catch (error) {\n      console.error('‚ùå Deployment demo failed:', error);\n    }\n  }\n\n  /**\n   * Deploy a simple Node.js application\n   */\n  private async deploySimpleNodeApp(): Promise<any> {\n    const files = [\n      {\n        path: 'package.json',\n        content: JSON.stringify({\n          name: 'simple-node-app',\n          version: '1.0.0',\n          main: 'index.js',\n          scripts: {\n            start: 'node index.js'\n          },\n          dependencies: {\n            express: '^4.18.0'\n          }\n        }, null, 2)\n      },\n      {\n        path: 'index.js',\n        content: `\nconst express = require('express');\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.get('/', (req, res) => {\n  res.json({ message: 'Simple Node.js app running!' });\n});\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', timestamp: new Date().toISOString() });\n});\n\napp.listen(port, () => {\n  console.log(\\`Server running on port \\${port}\\`);\n});\n        `\n      }\n    ];\n\n    return await this.orchestrationService.deployProject(\n      'simple-node-project-123',\n      'user-456',\n      files,\n      {\n        runtimeType: 'node',\n        buildCommand: 'npm install',\n        startCommand: 'npm start',\n        environmentVars: {\n          NODE_ENV: 'production',\n          PORT: '3000'\n        }\n      }\n    );\n  }\n\n  /**\n   * Deploy a complex React application\n   */\n  private async deployComplexReactApp(): Promise<any> {\n    const files = [\n      {\n        path: 'package.json',\n        content: JSON.stringify({\n          name: 'complex-react-app',\n          version: '1.0.0',\n          scripts: {\n            build: 'react-scripts build',\n            start: 'serve -s build -l 3000'\n          },\n          dependencies: {\n            react: '^18.0.0',\n            'react-dom': '^18.0.0',\n            'react-scripts': '^5.0.0',\n            'react-router-dom': '^6.0.0',\n            axios: '^1.0.0',\n            'styled-components': '^5.0.0',\n            serve: '^14.0.0'\n          }\n        }, null, 2)\n      },\n      // Simulate multiple component files\n      { path: 'src/App.js', content: '// React App Component' },\n      { path: 'src/components/Header.js', content: '// Header Component' },\n      { path: 'src/components/Footer.js', content: '// Footer Component' },\n      { path: 'src/pages/Home.js', content: '// Home Page Component' },\n      { path: 'src/pages/About.js', content: '// About Page Component' },\n      { path: 'src/utils/api.js', content: '// API utilities' },\n      { path: 'src/hooks/useAuth.js', content: '// Authentication hook' },\n      { path: 'public/index.html', content: '<!DOCTYPE html><html>...</html>' }\n    ];\n\n    return await this.orchestrationService.deployProject(\n      'complex-react-project-789',\n      'user-456',\n      files,\n      {\n        runtimeType: 'node',\n        buildCommand: 'npm install && npm run build',\n        startCommand: 'npm start',\n        timeout: 900, // 15 minutes for complex build\n        environmentVars: {\n          NODE_ENV: 'production',\n          REACT_APP_API_URL: 'https://api.example.com'\n        }\n      }\n    );\n  }\n\n  /**\n   * Monitor deployments and show health status\n   */\n  private async monitorDeployments(deploymentIds: string[]): Promise<void> {\n    console.log('\\nüìä === Monitoring Deployments ===');\n    \n    for (const deploymentId of deploymentIds) {\n      try {\n        const status = await this.orchestrationService.monitorDeployment(deploymentId);\n        console.log(`\\nüìà Deployment ${deploymentId}:`);\n        console.log(`   Status: ${status.status}`);\n        console.log(`   Health: ${status.health}`);\n        console.log(`   Uptime: ${Math.round(status.metrics.uptime / 1000)}s`);\n        console.log(`   Memory: ${status.metrics.memoryUsage}MB`);\n        console.log(`   CPU: ${Math.round(status.metrics.cpuUsage * 100)}%`);\n        \n        if (status.logs.length > 0) {\n          console.log('   Recent logs:');\n          status.logs.slice(-3).forEach(log => {\n            console.log(`     ${log}`);\n          });\n        }\n      } catch (error) {\n        console.error(`‚ùå Failed to monitor ${deploymentId}:`, error.message);\n      }\n    }\n  }\n\n  /**\n   * Simulate error conditions and recovery\n   */\n  private async simulateErrorRecovery(deploymentId: string): Promise<void> {\n    console.log('\\n‚ö†Ô∏è  === Error Recovery Demo ===');\n    \n    // Simulate different types of errors\n    const errorScenarios = [\n      {\n        name: 'Timeout Error',\n        error: new Error('Operation timed out after 300 seconds'),\n        stage: 'building' as const\n      },\n      {\n        name: 'Network Error', \n        error: new Error('Network connection failed: ECONNREFUSED'),\n        stage: 'deploying' as const\n      },\n      {\n        name: 'Resource Error',\n        error: new Error('Out of memory: Cannot allocate 512MB'),\n        stage: 'running' as const\n      }\n    ];\n\n    for (const scenario of errorScenarios) {\n      console.log(`\\nüîß Testing ${scenario.name}:`);\n      \n      try {\n        const recovery = await this.orchestrationService.handleErrors(\n          deploymentId,\n          scenario.error,\n          {\n            stage: scenario.stage,\n            retryCount: 0,\n            maxRetries: 3\n          }\n        );\n        \n        console.log(`   Recovery strategy: ${recovery.action}`);\n        console.log(`   Recovered: ${recovery.recovered}`);\n        \n        if (recovery.nextRetryIn) {\n          console.log(`   Next retry in: ${recovery.nextRetryIn}ms`);\n        }\n        \n      } catch (error) {\n        console.error(`   ‚ùå Error handling failed:`, error.message);\n      }\n    }\n  }\n\n  /**\n   * Demonstrate cleanup mechanisms\n   */\n  private async demonstrateCleanup(): Promise<void> {\n    console.log('\\nüßπ === Cleanup Demo ===');\n    \n    try {\n      // Show current sandbox count\n      const stats = await this.orchestrationService.getExecutionStats();\n      console.log(`Current active executions: ${stats.activeExecutions}`);\n      console.log(`Queued executions: ${stats.queuedExecutions}`);\n      \n      // Perform cleanup with different strategies\n      const cleanupResults = await this.orchestrationService.cleanupSandboxes({\n        maxAge: 30 * 60 * 1000,    // 30 minutes\n        maxIdle: 15 * 60 * 1000,   // 15 minutes\n        force: false\n      });\n      \n      console.log('\\nCleanup Results:');\n      console.log(`  Cleaned: ${cleanupResults.cleaned} sandboxes`);\n      console.log(`  Errors: ${cleanupResults.errors.length}`);\n      \n      if (cleanupResults.details.length > 0) {\n        console.log('  Details:');\n        cleanupResults.details.forEach(detail => {\n          const status = detail.success ? '‚úÖ' : '‚ùå';\n          console.log(`    ${status} ${detail.sandboxId}: ${detail.reason}`);\n        });\n      }\n      \n      if (cleanupResults.errors.length > 0) {\n        console.log('  Errors:');\n        cleanupResults.errors.forEach(error => {\n          console.log(`    ‚ùå ${error}`);\n        });\n      }\n      \n    } catch (error) {\n      console.error('‚ùå Cleanup demo failed:', error);\n    }\n  }\n\n  /**\n   * Demonstrate timeout strategies\n   */\n  async demonstrateTimeoutStrategies(): Promise<void> {\n    console.log('\\n‚è±Ô∏è  === Timeout Strategy Demo ===');\n    \n    const projectScenarios = [\n      {\n        name: 'Simple Node.js API',\n        files: [{ path: 'index.js', content: 'simple app' }],\n        dependencies: { express: '^4.18.0' },\n        expectedType: 'simple'\n      },\n      {\n        name: 'Complex React App',\n        files: new Array(25).fill(null).map((_, i) => ({ \n          path: `src/component${i}.js`, \n          content: 'component code' \n        })),\n        dependencies: {\n          react: '^18.0.0',\n          'react-dom': '^18.0.0',\n          'react-router-dom': '^6.0.0',\n          axios: '^1.0.0',\n          'styled-components': '^5.0.0'\n        },\n        expectedType: 'complex'\n      },\n      {\n        name: 'Enterprise Microservice',\n        files: new Array(75).fill(null).map((_, i) => ({ \n          path: `src/service${i}.js`, \n          content: 'service code' \n        })),\n        dependencies: Object.fromEntries(\n          new Array(20).fill(null).map((_, i) => [`package${i}`, '^1.0.0'])\n        ),\n        expectedType: 'enterprise'\n      }\n    ];\n\n    for (const scenario of projectScenarios) {\n      console.log(`\\nüìã ${scenario.name}:`);\n      console.log(`   Files: ${scenario.files.length}`);\n      console.log(`   Dependencies: ${Object.keys(scenario.dependencies).length}`);\n      console.log(`   Expected type: ${scenario.expectedType}`);\n      \n      // This would be called internally by the OrchestrationService\n      // const detectedType = TIMEOUT_STRATEGY_MATRIX.detectProjectType(\n      //   scenario.files, \n      //   scenario.dependencies\n      // );\n      // console.log(`   Detected type: ${detectedType}`);\n    }\n  }\n\n  /**\n   * Run all demonstrations\n   */\n  async runFullDemo(): Promise<void> {\n    console.log('üé≠ CodeRunner v2.0 Deployment Strategy Demonstration');\n    console.log('=' .repeat(60));\n    \n    try {\n      // Initialize services\n      await this.databaseService.connect();\n      console.log('‚úÖ Database connected');\n      \n      // Run demonstrations\n      await this.demonstrateTimeoutStrategies();\n      await this.demonstrateDeploymentLifecycle();\n      \n      console.log('\\nüéâ === Demo Complete ===');\n      console.log('All deployment strategy features demonstrated successfully!');\n      \n    } catch (error) {\n      console.error('‚ùå Demo failed:', error);\n    } finally {\n      // Cleanup\n      await this.orchestrationService.cleanup();\n      await this.databaseService.disconnect();\n      console.log('‚úÖ Services cleaned up');\n    }\n  }\n}\n\n// Run the demo if this file is executed directly\nif (require.main === module) {\n  const demo = new DeploymentStrategyDemo();\n  demo.runFullDemo().catch(console.error);\n}\n\nexport { DeploymentStrategyDemo };"